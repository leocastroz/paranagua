import { defineComponent as m, ref as d, watchEffect as y, openBlock as n, createElementBlock as c, normalizeStyle as h, withModifiers as v, createElementVNode as u, createCommentVNode as l, toDisplayString as T, reactive as C, createBlock as g, Teleport as O, createVNode as k, Transition as V, withCtx as b, Fragment as w, renderList as H, unref as x } from "vue";
const E = ["onClick"], j = { class: "VueHotToast__icon" }, S = {
  key: 0,
  class: "VueHotToast__checkmark"
}, I = {
  key: 1,
  class: "VueHotToast__error"
}, B = {
  key: 2,
  class: "VueHotToast__loading"
}, D = { class: "content" }, M = { class: "content-message" }, N = /* @__PURE__ */ m({
  __name: "ToasterItem",
  props: {
    id: {},
    type: {},
    message: {},
    autoClose: { type: Boolean },
    duration: {}
  },
  emits: ["close"],
  setup(t, { emit: e }) {
    const o = t, s = d(null), r = d(0), p = d(0), f = () => {
      e("close");
    };
    return y(() => {
      o.autoClose && (r.value = Date.now(), p.value = o.duration, s.value = setTimeout(f, p.value));
    }), (i, F) => (n(), c("div", {
      class: "VueHotToast__toast",
      style: h(`--toast-duration: ${i.duration}s;`),
      onClick: v(f, ["prevent"])
    }, [
      u("div", j, [
        i.type === "success" ? (n(), c("div", S)) : l("", !0),
        i.type === "error" ? (n(), c("div", I)) : l("", !0),
        i.type === "loading" ? (n(), c("div", B)) : l("", !0)
      ]),
      u("div", D, [
        u("div", M, T(i.message), 1)
      ])
    ], 12, E));
  }
}), U = {
  type: "info",
  message: "Here's your toast.",
  autoClose: !0,
  duration: 3e3
};
function $() {
  let t = (/* @__PURE__ */ new Date()).getTime();
  var e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
    /[xy]/g,
    function(o) {
      var s = (t + Math.random() * 16) % 16 | 0;
      return t = Math.floor(t / 16), (o == "x" ? s : s & 3 | 8).toString(16);
    }
  );
  return e;
}
const a = C({
  notifications: []
}), _ = function() {
  const t = (e) => {
    const o = Object.assign({ ...U }, e), s = $();
    return a.notifications.push(
      {
        id: s,
        ...o
      }
    ), s;
  };
  return t.update = (e, o) => {
    const s = a.notifications.findIndex(
      (r) => r.id === e
    );
    if (s === -1)
      throw t(o), new Error("Can't find toast");
    return Object.assign(a.notifications[s], o), e;
  }, t._handleOptions = (e, o) => {
    const s = Object.assign(o ?? {}, { type: e });
    return t(s);
  }, t.loading = (e, o) => t._handleOptions(
    "loading",
    Object.assign(o ?? {}, { message: e })
  ), t.success = (e, o) => t._handleOptions(
    "success",
    Object.assign(o ?? {}, { message: e })
  ), t.error = (e, o) => t._handleOptions(
    "error",
    Object.assign(o ?? {}, { message: e })
  ), t.promise = (e, o) => {
    const s = t.loading(o.loading);
    return e.then((r) => (t.update(s, {
      message: o.success,
      type: "success"
    }), s)).catch((r) => {
      throw t.update(s, {
        message: o.error,
        type: "error"
      }), r;
    });
  }, t;
}(), L = (t) => {
  const e = a.notifications.findIndex((o) => o.id === t);
  e !== -1 && a.notifications.splice(e, 1);
}, z = { class: "VueHotToast__toast-container" }, R = /* @__PURE__ */ m({
  __name: "Toaster",
  setup(t) {
    return (e, o) => (n(), g(O, { to: "body" }, [
      k(V, {
        name: "VueHotToast__teleport-transition",
        tag: "div",
        class: "VueHotToast__teleport-transition"
      }, {
        default: b(() => [
          u("div", z, [
            (n(!0), c(w, null, H(x(a).notifications, (s) => (n(), g(N, {
              key: s.id,
              id: s.id,
              type: s.type,
              message: s.message,
              "auto-close": s.autoClose,
              duration: s.duration,
              onClose: () => {
                x(L)(s.id);
              }
            }, null, 8, ["id", "type", "message", "auto-close", "duration", "onClose"]))), 128))
          ])
        ]),
        _: 1
      })
    ]));
  }
});
function q(t) {
  return _.loading(t, {
    autoClose: !1
  });
}
function G(t, e) {
  _.update(e, {
    message: t,
    type: "success",
    autoClose: !0,
    duration: 3e3
  });
}
function K(t, e) {
  _.update(e, {
    message: A(t),
    type: "error",
    autoClose: !0,
    duration: 3e3
  });
}
function A(t) {
  if (!t)
    return "Undefined Error";
  if (typeof t == "string")
    return t;
  if (t instanceof Error) {
    const e = t;
    return e.reason ?? e.message;
  } else
    return JSON.stringify(t);
}
export {
  R as Toaster,
  _ as toast,
  K as toastError,
  q as toastLoading,
  G as toastSuccess
};
